---
title: "Why Python, JavaScript, and C++ Rule the Programming World"
description: "In the '90s, Perl dominated the scripting world with regex prowess, but Python arrived at just the right moment to shift the game. Meanwhile, JavaScript rose to fame as the backbone of front-end development. Dive into how CPython and Node.js shape these languages and why it's dangerous to idolize programming languages."
pubDatetime: 2025-01-25T16:50:05Z
tags: ["python", "javascript", "cpp", "programming history", "cpython", "nodejs"]
author: "Bruno Ciccarino"
featured: false
draft: false
---

Hey there, programmer! Let’s talk about some of the languages that have shaped the way we write code today. Python, JavaScript, and C++ are titans in their domains, but the stories behind them are as fascinating as their capabilities. So grab your coffee (or tea—no judgment here), and let’s dive in.

### Lua: A Hidden Gem with Incredible Potential
Before diving into Python and JavaScript, let’s take a moment to appreciate Lua. Designed to be lightweight, fast, and highly embeddable, Lua has found its niche in game development and other performance-critical areas. What makes Lua particularly exciting is **LuaJIT**, a Just-In-Time compiler that offers blazing performance rivaling even C in some scenarios. Combine that with a syntax that is both simple and powerful, and you have a language that punches well above its weight.

Lua’s flexibility and efficiency make it a strong contender for the future of scripting, especially in environments where resources are limited but performance is critical. Whether it will achieve mainstream adoption remains to be seen, but it’s certainly a language worth keeping an eye on.

### The '90s: When Perl Ruled the Scripting World
Back in the 1990s, if you were talking about scripting languages, you were talking about Perl. It was **the** go-to tool for text processing, especially because of its unrivaled ability to handle regular expressions (regex). Need to parse a log file? Perl had you covered. Its slogan, "There’s more than one way to do it," made it incredibly versatile, though also a bit chaotic.

But then came Python.

### Enter Python: The Right Language at the Right Time
In the early '90s, Guido van Rossum introduced Python, and it brought a breath of fresh air to scripting. Where Perl emphasized flexibility (sometimes to a fault), Python championed readability and simplicity. Python’s clean syntax and focus on developer experience made it a perfect fit for the growing need for scripting languages. As software development expanded beyond seasoned pros to include newer developers, Python became the scripting language people could actually read and learn without pulling their hair out.

Fast forward to today, and Python’s versatility has made it a cornerstone in fields like data science, machine learning, web development, and even automation.

### JavaScript: The Language Every Front-End Developer Had to Love
While Python was gaining traction, JavaScript was being embedded into every browser in existence. At first, it was a simple language designed for scripting web pages, but as web development matured, JavaScript became unavoidable. Whether you were styling a button or building a full-blown application, if it was in a browser, you needed JavaScript.

This ubiquity paved the way for JavaScript’s meteoric rise. Love it or hate it, every front-end developer had to learn JavaScript—and this necessity gave it a cultural momentum that few other languages have achieved.

### CPython and Node.js: Built with C and C++
Here’s where things get a bit more technical. Python’s most widely used implementation, CPython, and JavaScript’s runtime, Node.js, are both written primarily in C and C++. Why? Because C and C++ are incredibly efficient at handling low-level operations like memory management. They’re the unsung heroes enabling high-level languages to be fast and powerful.

But here’s a twist: CPython and Node.js are not identical beasts under the hood. On Windows, Linux, and macOS, they behave slightly differently. Why? Because their codebases include **preprocessor directives** (those lines starting with `#ifdef` or `#if`) to adapt to the quirks of each operating system. These directives act as switchboards, activating the OS-specific parts of the code while keeping the core functionality consistent.

### Why C and C++ Aren't Going Anywhere
Despite the rise of modern languages like Rust, Go, and Zig, none of them are likely to replace C and C++ anytime soon. Why? Because an estimated **70% of the internet’s infrastructure is built on C and C++**. From web servers to operating systems, these languages form the backbone of our digital world. 

Their unparalleled efficiency and performance make them indispensable for system-level programming and resource-critical applications. Sure, Rust offers safety guarantees, and Go is great for concurrency, but rewriting the internet isn’t feasible—not in the near future, anyway.

C and C++ also have decades of libraries, tools, and developer expertise backing them up. The sheer momentum of these languages ensures that they’ll continue to dominate in areas where speed and control matter most. So while modern languages may nibble at their edges, C and C++ remain the kings of the core.

### Let’s Not Worship Programming Languages
It’s easy to get attached to a language, especially when it solves your problems so elegantly. But no language is perfect. Python has its speed limitations. JavaScript can be, well, a hot mess at times. Even C++ can make your head spin with its complexity. Idolizing a language blinds you to its flaws and limits your ability to choose the right tool for the job.

### What About You?
Now that we’ve walked through the evolution of these languages and their underlying tech, let me ask you: **What’s your favorite programming language, and why do you use it over others?** Is it about comfort, power, or just sheer habit? Let me know—I’d love to hear your story!